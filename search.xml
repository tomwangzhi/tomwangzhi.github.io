<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>zookeeper-命令行工具zkCli使用</title>
    <url>/2019/12/30/zookeeper-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7zkCli%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h4 id="zkCli使用"><a href="#zkCli使用" class="headerlink" title="zkCli使用"></a>zkCli使用</h4><h5 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h5><blockquote>
<p>必须确保服务器已安装zookeeper</p>
<p>echo ruok|nc 127.0.0.1 2181     使用四字命令检测zookeeper是否运行</p>
</blockquote>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>ZooKeeper客户端有C语言和Java两个版本。</p>
<p>在zookeeper安装目录的/bin文件夹下。</p>
<p>使用如图所示命令表示，使用zkCli.sh连接到zookeeper服务端成功。</p>
<p><img src="/images/zkcli.jpg" alt=""></p>
<h5 id="四字命令"><a href="#四字命令" class="headerlink" title="四字命令"></a>四字命令</h5><table>
<thead>
<tr>
<th><strong>ZooKeeper 四字命令</strong></th>
<th><strong>功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>conf</td>
<td>输出相关服务配置的详细信息。</td>
</tr>
<tr>
<td>cons</td>
<td>列出所有连接到服务器的客户端的完全的连接 / 会话的详细信息。包括“接受 / 发送”的包数量、会话 id 、操作延迟、最后的操作执行等等信息。</td>
</tr>
<tr>
<td>dump</td>
<td>列出未经处理的会话和临时节点。</td>
</tr>
<tr>
<td>envi</td>
<td>输出关于服务环境的详细信息（区别于 conf 命令）。</td>
</tr>
<tr>
<td>reqs</td>
<td>列出未经处理的请求</td>
</tr>
<tr>
<td>ruok</td>
<td>测试服务是否处于正确状态。如果确实如此，那么服务返回“imok ”，否则不做任何相应。</td>
</tr>
<tr>
<td>stat</td>
<td>输出关于性能和连接的客户端的列表。</td>
</tr>
<tr>
<td>wchs</td>
<td>列出服务器 watch 的详细信息。</td>
</tr>
<tr>
<td>wchc</td>
<td>通过 session 列出服务器 watch 的详细信息，它的输出是一个与watch 相关的会话的列表。</td>
</tr>
<tr>
<td>wchp</td>
<td>通过路径列出服务器 watch 的详细信息。它输出一个与 session相关的路径。</td>
</tr>
</tbody></table>
<p>例如使用案例：</p>
<p><img src="/images/zkcli1.jpg" alt=""></p>
<h5 id="常见使用案例"><a href="#常见使用案例" class="headerlink" title="常见使用案例"></a>常见使用案例</h5><ol>
<li><strong>使用 ls 命令来查看当前 ZooKeeper 中所包含的内容</strong></li>
</ol>
<p><img src="/images/zkcli2.jpg" alt=""></p>
<ol start="2">
<li><p>*<em>创建一个新的 znode ，使用 create /mynode  ‘aaa’ 绑定字符串 aaa *</em></p>
<p><img src="/images/zkcli3.jpg" alt=""></p>
</li>
<li><p>*<em>获取节点下面绑定的信息 get /mynode *</em> </p>
<p><img src="/images/zkcli4.jpg" alt=""></p>
</li>
<li><p><strong>通过 set 命令来对 zk 所关联的字符串进行设置： set /mynode ‘ddd’</strong></p>
</li>
<li><p><strong>创建的 znode 删除: delete /mynode</strong></p>
</li>
</ol>
<h5 id="节点各个参数详解："><a href="#节点各个参数详解：" class="headerlink" title="节点各个参数详解："></a>节点各个参数详解：</h5><p>节点的路径皆为绝对路径</p>
<p><img src="/images/zkcli4.jpg" alt=""></p>
<blockquote>
<p>cZxid节点创建时的zxid</p>
<p>ctime节点创建时间</p>
<p>mZxid节点最近一次更新时的zxid</p>
<p>mtime节点最近一次更新的时间</p>
<p>cversion子节点数据更新次数</p>
<p>dataVersion本节点数据更新次数</p>
<p>aclVersion节点ACL(授权信息)的更新次数</p>
<p>ephemeralOwner如果该节点为临时节点,ephemeralOwner值表示与该节点绑定的session id. 如果该节点不是临时节点,ephemeralOwner值为0</p>
<p>dataLength节点数据长度，本例中为hello world的长度</p>
<p>numChildren子节点个数</p>
</blockquote>
]]></content>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>zookeeper概述</title>
    <url>/2019/12/30/zookeeper%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h4 id="zookeeper概述"><a href="#zookeeper概述" class="headerlink" title="zookeeper概述"></a>zookeeper概述</h4><p>zookeeper是一种分布式协调服务，用于大型主机。在分布式环境中，协调和管理服务是一个复杂的过程，但是zookeeper以其简单的机构和 API 解决了该问题。zookeeper最先开始是在 Yahoo 上使用的，用简单而稳健的访问内部的系统。</p>
<h5 id="分布式应用"><a href="#分布式应用" class="headerlink" title="分布式应用"></a>分布式应用</h5><blockquote>
<p><strong>定义</strong>：分布式应用可以在给定时间同时在网络的多个系统上运行，通过协调他们完成共同的任务。复杂的任务在分布式环境下可以用更少的时间完成，不像传统单体应用耗时过多。</p>
<p><strong>组成</strong>：分布式应用有两部分， <strong>Server（服务器）</strong> 和 <strong>Client（客户端）</strong> 应用程序。服务器应用程序实际上是分布式的，并具有通用接口，以便客户端可以连接到集群中的任何服务器并获得相同的结果。 客户端应用程序是与分布式应用进行交互的工具。</p>
</blockquote>
<p><img src="/images/zookeeper.jpg" alt=""></p>
<blockquote>
<p><strong>优点：</strong></p>
<p>可靠性：单个或几个系统故障不会使整个系统奔溃</p>
<p>可扩展性：可以在需要时增加系统的性能，在应用程序进行微小的配置的更改，而不会有停机时间</p>
<p>透明性：隐藏系统的复杂性。</p>
<p><strong>缺点：</strong></p>
<p>竞争条件：两个或多个机器尝试执行特定任务，实际上只需在任意给定时间由单个机器完成</p>
<p>死锁：两个或多个操作等待彼此无限期完成。</p>
<p>不一致: 数据的部分失败</p>
</blockquote>
<h4 id="什么是-Apache-zookeeper"><a href="#什么是-Apache-zookeeper" class="headerlink" title="什么是 Apache  zookeeper?"></a>什么是 Apache  zookeeper?</h4><p>Apache ZooKeeper是由集群（节点组）使用的一种服务，用于在自身之间协调，并通过稳健的同步技术维护共享数据。ZooKeeper本身是一个分布式应用程序，为写入分布式应用程序提供服务。</p>
<blockquote>
<p>提供的服务：</p>
<p><strong>命名服务</strong>: 按名称标识集群中的节点</p>
<p>配置管理：加入节点的最近和最新的配置信息</p>
<p>集群管理：实时的在集群和节点状态中加入/离开节点</p>
<p>选举算法：选举一个节点作为协调目的的leader</p>
<p><strong>高度可靠的数据注册表</strong>：即使在一个或几个节点关闭时也可以获得数据</p>
<p><strong>锁定和同步服务</strong> - 在修改数据的同时锁定数据。</p>
</blockquote>
<blockquote>
<p>优点：</p>
<ul>
<li><strong>简单的分布式协调过程</strong></li>
<li><strong>同步</strong> - 服务器进程之间的相互排斥和协作。此过程有助于Apache HBase进行配置管理。</li>
<li><strong>有序的消息</strong></li>
<li><strong>序列化</strong> - 根据特定规则对数据进行编码。确保应用程序运行一致。这种方法可以在MapReduce中用来协调队列以执行运行的线程。</li>
<li><strong>可靠性</strong></li>
<li><strong>原子性</strong> - 数据转移完全成功或完全失败，但没有事务是部分的。</li>
</ul>
</blockquote>
]]></content>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>小工具-StopWatch</title>
    <url>/2019/12/27/%E5%B0%8F%E5%B7%A5%E5%85%B7-StopWatch/</url>
    <content><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><blockquote>
<p>平时我们在优化代码时，必不可少的需要知道每一段业务逻辑的耗时情况。之前我习惯了用如下这种方式去打印每一段的耗时情况。一段逻辑复杂时，可能整段代码都是 如下，这种方式打印也不直观，直到发现 spring 本身的 util 包下有个工具StopWatch，才发现是如此的好用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">long start &#x3D; System.currentTimeMillis();</span><br><span class="line">handle();</span><br><span class="line">long end &#x3D; System.currentTimeMillis();</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="StopWatch使用"><a href="#StopWatch使用" class="headerlink" title="StopWatch使用"></a>StopWatch使用</h4><p>类构造方法、普通方法、属性概览：</p>
<p><img src="images/stopwatch.jpg" alt=""></p>
<p>使用步骤：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StopWatch stopWatch = <span class="keyword">new</span> StopWatch(<span class="string">"bussiness Id"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码片段1</span></span><br><span class="line">stopWatch.start(<span class="string">"bussiness1"</span>);</span><br><span class="line">executeBussiness1();</span><br><span class="line">stopWatch.stop();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码片段2</span></span><br><span class="line">stopWatch.start(<span class="string">"bussiness2"</span>);</span><br><span class="line">executeBussiness2();</span><br><span class="line">stopWatch.stop();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印所有片段执行情况</span></span><br><span class="line">String recordInfo = stopWatch.prettyPrint();</span><br><span class="line">System.out.println(recordInfo);</span><br></pre></td></tr></table></figure>



<p>源码学习的点：</p>
<blockquote>
<p>由于底层是用一个linkList来记录每一段代码的执行，所有不要使用在多线程的环境中，是线程不安全的。可以通过 taskList 得到所有片段执行的情况。</p>
</blockquote>
]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>java五种单例模式</title>
    <url>/2019/12/25/java%E4%BA%94%E7%A7%8D%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h4 id="✎简介"><a href="#✎简介" class="headerlink" title="✎简介"></a><center><font color = "#36648B">✎</font><br/><font color = "#36648B">简介</font></center></h4><pre><code>单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。
本篇文章主要来简介下五种常见的单例模式【实现方法】以及【各自的区别】。
五种方式：懒汉式、饿汉式、双校验锁、静态内部类、枚举。</code></pre><hr>
<h4 id="✎-懒汉式"><a href="#✎-懒汉式" class="headerlink" title="✎ 懒汉式"></a><center><font color = "#36648B">✎</font><br/><font color = "#36648B"> 懒汉式</font></center></h4><h5 id="☞代码"><a href="#☞代码" class="headerlink" title="☞代码"></a>☞代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Apple apple = <span class="keyword">new</span> Apple();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FruitFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Apple <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> apple;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="☞总结"><a href="#☞总结" class="headerlink" title="☞总结"></a>☞总结</h5><blockquote>
<ol>
<li>场景：适用于占用内存较小的小对象。懒汉式实例化的时机是在类加载的时候对实例进行创建。</li>
<li>优点：在多线程中不会关心是否加锁同步类的问题。</li>
<li>缺点：不管是否使用该实例，都会被实例化到内存中去。</li>
</ol>
</blockquote>
<hr>
<h4 id="✎饿汉式"><a href="#✎饿汉式" class="headerlink" title="✎饿汉式"></a><center><font color = "#36648B">✎</font><br/><font color = "#36648B">饿汉式</font></center></h4><h5 id="☞代码-1"><a href="#☞代码-1" class="headerlink" title="☞代码"></a>☞代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Apple apple = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FruitFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Apple <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (apple == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Apple();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> apple;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="☞总结-1"><a href="#☞总结-1" class="headerlink" title="☞总结"></a>☞总结</h5><blockquote>
<p>场景： 适用单线程环境并且对象占用内存较大的场景。<br>优点： 只是在调用的时候才会实例化对象，跟懒汉的模式是不一样的。<br>缺点： 不能适用多线程的场景，需要加锁解决线程同步问题。</p>
</blockquote>
<hr>
<h4 id="✎双校验锁"><a href="#✎双校验锁" class="headerlink" title="✎双校验锁 "></a><center><font color = "#36648B">✎</font><br/><font color = "#36648B">双校验锁 </font></center></h4><h5 id="☞-代码"><a href="#☞-代码" class="headerlink" title="☞ 代码"></a>☞ 代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Apple apple = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FruitFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Apple <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(apple == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (FruitFactory<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (apple == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> Apple();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> apple;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="☞总结-2"><a href="#☞总结-2" class="headerlink" title="☞总结"></a>☞总结</h5><blockquote>
<p>场景：适用多线程，延迟加载的场景<br>优点：可以用在多线程下面，在 1.5 之后的版本中用  volatile 解决了校验锁会失效的问题<br>缺点：1.4 之前的版本没有 volatile 关键字，可能会有失败的情形，因为涉及到指令的重排序<br>两次校验原因：<br>a.  第一次判断 singleton 是否为 null: 是为了在第一次创建实例化后，后面获取不用再进入同步代码块中，提高了性能<br>b. 第一次判断 singleton 是否为 null: 假设其中一个线程进行判断准备进入同步代码块，但是另外一个线程获得调度的时间片，这是没有实例化满足为null的情况进入同步快中，实例完后，前面的线程获得锁然后继续执行又创建一个实例。所以里面的判断是必要的。<br>c. 用 volatile原因： volatile 可以保证可见性和原子性，同时保证 JVM 对指令不会进行重排序 new Apple() 是分几步执行的：<br>   指令1：获取apple对象的内存地址<br>  指令2：初始化apple对象<br>  指令3：将这块内存地址，指向引用变量apple。<br>加入重排后的执行指令按 2-1-3 执行，线程 a 执行到指令1时，另外一个线程 b 去调用getInstance 获得对象就不是完整的，就会导致异常的产生。</p>
</blockquote>
<hr>
<h4 id="✎静态内部类"><a href="#✎静态内部类" class="headerlink" title="✎静态内部类 "></a><center><font color = "#36648B">✎</font><br/><font color = "#36648B">静态内部类 </font></center></h4><h5 id="☞代码-2"><a href="#☞代码-2" class="headerlink" title="☞代码"></a>☞代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitInstance</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Apple apple = <span class="keyword">new</span> Apple();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Apple <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> FruitInstance.apple;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="☞总结-3"><a href="#☞总结-3" class="headerlink" title="☞总结"></a>☞总结</h5><blockquote>
<p>场景：适用于多线程，延迟加载的场景<br>优点：只在调用的时候才加载实例化内部类<br>缺点：可以强制利用反射来调用私有构造</p>
</blockquote>
<hr>
<h4 id="✎枚举"><a href="#✎枚举" class="headerlink" title="✎枚举 "></a><center><font color = "#36648B">✎</font><br/><font color = "#36648B">枚举 </font></center></h4><h5 id="☞代码-3"><a href="#☞代码-3" class="headerlink" title="☞代码"></a>☞代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> FruitType &#123;</span><br><span class="line"></span><br><span class="line">    Apple;</span><br><span class="line">    <span class="keyword">private</span> Apple apple;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FruitType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        apple = <span class="keyword">new</span> Apple();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Apple <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Apple.apple;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="☞总结-4"><a href="#☞总结-4" class="headerlink" title="☞总结"></a>☞总结</h5><blockquote>
<p>明确了构造方法限制为私有，在我们访问枚举实例时会执行构造方法<br>枚举实例都是static final类型的,所以只会实例化一次<br>枚举除了线程安全和防止反射调用构造器之外，还提供了自动序列化机制，防止反序列化的时候创建新的对象</p>
</blockquote>
<h4 id="✎对比"><a href="#✎对比" class="headerlink" title="✎对比 "></a><center><font color = "#36648B">✎</font><br/><font color = "#36648B">对比 </font></center></h4><table>
<thead>
<tr>
<th>方式</th>
<th>是否线程安全</th>
</tr>
</thead>
<tbody><tr>
<td>懒汉式</td>
<td>是</td>
</tr>
<tr>
<td>饿汉式</td>
<td>否</td>
</tr>
<tr>
<td>双校验</td>
<td>是</td>
</tr>
<tr>
<td>静态内部类</td>
<td>是</td>
</tr>
<tr>
<td>枚举</td>
<td>是</td>
</tr>
</tbody></table>
<p><strong>参考：</strong> </p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式，单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub+Hexo搭建博客系统</title>
    <url>/2019/12/24/GitHub-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
</search>
