<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>java五种单例模式</title>
    <url>/2019/12/25/java%E4%BA%94%E7%A7%8D%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h4 id="✎简介"><a href="#✎简介" class="headerlink" title="✎简介"></a><center><font color = "#36648B">✎</font><br/><font color = "#36648B">简介</font></center></h4><pre><code>单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。
本篇文章主要来简介下五种常见的单例模式【实现方法】以及【各自的区别】。
五种方式：懒汉式、饿汉式、双校验锁、静态内部类、枚举。</code></pre><hr>
<h4 id="✎-懒汉式"><a href="#✎-懒汉式" class="headerlink" title="✎ 懒汉式"></a><center><font color = "#36648B">✎</font><br/><font color = "#36648B"> 懒汉式</font></center></h4><h5 id="☞代码"><a href="#☞代码" class="headerlink" title="☞代码"></a>☞代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Apple apple = <span class="keyword">new</span> Apple();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FruitFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Apple <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> apple;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="☞总结"><a href="#☞总结" class="headerlink" title="☞总结"></a>☞总结</h5><blockquote>
<ol>
<li>场景：适用于占用内存较小的小对象。懒汉式实例化的时机是在类加载的时候对实例进行创建。</li>
<li>优点：在多线程中不会关心是否加锁同步类的问题。</li>
<li>缺点：不管是否使用该实例，都会被实例化到内存中去。</li>
</ol>
</blockquote>
<hr>
<h4 id="✎饿汉式"><a href="#✎饿汉式" class="headerlink" title="✎饿汉式"></a><center><font color = "#36648B">✎</font><br/><font color = "#36648B">饿汉式</font></center></h4><h5 id="☞代码-1"><a href="#☞代码-1" class="headerlink" title="☞代码"></a>☞代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Apple apple = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FruitFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Apple <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (apple == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Apple();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> apple;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="☞总结-1"><a href="#☞总结-1" class="headerlink" title="☞总结"></a>☞总结</h5><blockquote>
<p>场景： 适用单线程环境并且对象占用内存较大的场景。<br>优点： 只是在调用的时候才会实例化对象，跟懒汉的模式是不一样的。<br>缺点： 不能适用多线程的场景，需要加锁解决线程同步问题。</p>
</blockquote>
<hr>
<h4 id="✎双校验锁"><a href="#✎双校验锁" class="headerlink" title="✎双校验锁 "></a><center><font color = "#36648B">✎</font><br/><font color = "#36648B">双校验锁 </font></center></h4><h5 id="☞-代码"><a href="#☞-代码" class="headerlink" title="☞ 代码"></a>☞ 代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Apple apple = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FruitFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Apple <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(apple == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (FruitFactory<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (apple == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> Apple();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> apple;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="☞总结-2"><a href="#☞总结-2" class="headerlink" title="☞总结"></a>☞总结</h5><blockquote>
<p>场景：适用多线程，延迟加载的场景<br>优点：可以用在多线程下面，在 1.5 之后的版本中用  volatile 解决了校验锁会失效的问题<br>缺点：1.4 之前的版本没有 volatile 关键字，可能会有失败的情形，因为涉及到指令的重排序<br>两次校验原因：<br>a.  第一次判断 singleton 是否为 null: 是为了在第一次创建实例化后，后面获取不用再进入同步代码块中，提高了性能<br>b. 第一次判断 singleton 是否为 null: 假设其中一个线程进行判断准备进入同步代码块，但是另外一个线程获得调度的时间片，这是没有实例化满足为null的情况进入同步快中，实例完后，前面的线程获得锁然后继续执行又创建一个实例。所以里面的判断是必要的。<br>c. 用 volatile原因： volatile 可以保证可见性和原子性，同时保证 JVM 对指令不会进行重排序 new Apple() 是分几步执行的：<br>   指令1：获取apple对象的内存地址<br>  指令2：初始化apple对象<br>  指令3：将这块内存地址，指向引用变量apple。<br>加入重排后的执行指令按 2-1-3 执行，线程 a 执行到指令1时，另外一个线程 b 去调用getInstance 获得对象就不是完整的，就会导致异常的产生。</p>
</blockquote>
<hr>
<h4 id="✎静态内部类"><a href="#✎静态内部类" class="headerlink" title="✎静态内部类 "></a><center><font color = "#36648B">✎</font><br/><font color = "#36648B">静态内部类 </font></center></h4><h5 id="☞代码-2"><a href="#☞代码-2" class="headerlink" title="☞代码"></a>☞代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitInstance</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Apple apple = <span class="keyword">new</span> Apple();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Apple <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> FruitInstance.apple;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="☞总结-3"><a href="#☞总结-3" class="headerlink" title="☞总结"></a>☞总结</h5><blockquote>
<p>场景：适用于多线程，延迟加载的场景<br>优点：只在调用的时候才加载实例化内部类<br>缺点：可以强制利用反射来调用私有构造</p>
</blockquote>
<hr>
<h4 id="✎枚举"><a href="#✎枚举" class="headerlink" title="✎枚举 "></a><center><font color = "#36648B">✎</font><br/><font color = "#36648B">枚举 </font></center></h4><h5 id="☞代码-3"><a href="#☞代码-3" class="headerlink" title="☞代码"></a>☞代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> FruitType &#123;</span><br><span class="line"></span><br><span class="line">    Apple;</span><br><span class="line">    <span class="keyword">private</span> Apple apple;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FruitType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        apple = <span class="keyword">new</span> Apple();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Apple <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Apple.apple;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="☞总结-4"><a href="#☞总结-4" class="headerlink" title="☞总结"></a>☞总结</h5><blockquote>
<p>明确了构造方法限制为私有，在我们访问枚举实例时会执行构造方法<br>枚举实例都是static final类型的,所以只会实例化一次<br>枚举除了线程安全和防止反射调用构造器之外，还提供了自动序列化机制，防止反序列化的时候创建新的对象</p>
</blockquote>
<h4 id="✎对比"><a href="#✎对比" class="headerlink" title="✎对比 "></a><center><font color = "#36648B">✎</font><br/><font color = "#36648B">对比 </font></center></h4><table>
<thead>
<tr>
<th>方式</th>
<th>是否线程安全</th>
</tr>
</thead>
<tbody><tr>
<td>懒汉式</td>
<td>是</td>
</tr>
<tr>
<td>饿汉式</td>
<td>否</td>
</tr>
<tr>
<td>双校验</td>
<td>是</td>
</tr>
<tr>
<td>静态内部类</td>
<td>是</td>
</tr>
<tr>
<td>枚举</td>
<td>是</td>
</tr>
</tbody></table>
<p><strong>参考：</strong> </p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式，单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub+Hexo搭建博客系统</title>
    <url>/2019/12/24/GitHub-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
</search>
