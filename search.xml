<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>kafka高性能原理和性能优化</title>
    <url>/2020/03/18/kafka%E9%AB%98%E6%80%A7%E8%83%BD%E5%8E%9F%E7%90%86%E5%92%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ol>
<li>kafka架构</li>
<li>高性能解读</li>
<li>配置参数调优</li>
<li>kafka对比其他消息系统</li>
</ol>
<center><font color = "#36648B">✎</font><br/><font color = "#36648B">kafka架构</font></center>

<p><strong>Kafka体系结构</strong></p>
<p><img src="/images/kafka.jpg" alt=""></p>
<p><strong>kafka topic多副本架构</strong></p>
<blockquote>
<p>每个 borker 有 leader 和 follower 而一个leader 下面的 follwer 可以分布在不同的 broker 中。就可以让 topic 分布在多台主机中</p>
</blockquote>
<p><img src="/images/kafka2.jpg" alt=""></p>
<p><strong>Kafka架构特点</strong></p>
<blockquote>
<p>分布式： Broker 节点可以水平扩展</p>
<p>扩展性： Topic 下分区 Partion 的水平扩展</p>
<p>高可用： Toipc下每一个分区(Partition)都是有备份机制，leader负责处理读写请求，follow负责同步备份，故障时支持主从切换。</p>
</blockquote>
<p><strong>问题？</strong></p>
<blockquote>
<ol>
<li><p>kafka 的消息是有序的吗？</p>
<p>partition内部的数据有效性（追加写、offset读），提高Topic的并发吞吐能力，可以提高Topic的partition数。但是多个 partition 不能保证Topic级别的数据有序性</p>
</li>
<li><p>kafka生产者到服务端发送消息是push还是pull？</p>
<p>push</p>
</li>
<li><p>kafka消费者到服务端获取消息是push还是pull？</p>
<p>pull</p>
</li>
</ol>
</blockquote>
<center><font color = "#36648B">✎</font><br/><font color = "#36648B">kafka高性能解读</font></center>

<p><strong>顺序写盘</strong></p>
<p>顺序写代替随机写。Kafka采用了文件追加的方式来写入消息，只能在日志文件的尾部追加新的消<br>息，且不允许修改已写入的消息，顺序写盘以提高性能。</p>
<p><img src="/images/kafka3.jpg" alt=""></p>
<p>联系：MySql的RedoLog，MongoDB的Journal日志</p>
<p>顺序写盘性能对比：</p>
<p><img src="/images/kafka4.jpg" alt=""></p>
<p><strong>零拷贝</strong></p>
<p>零拷贝技术可以减少数据拷贝和共享总线操作的次数，消除传输数据在存储器之间不必要的中间拷贝次数，从而有效地提高数据传输效率</p>
<p><img src="/images/kafka5.jpg" alt=""></p>
<p><img src="/images/kafka6.jpg" alt=""></p>
<p><strong>页缓存</strong></p>
<p>利用操作系统的缓存管理</p>
<p><img src="/images/kafka7.jpg" alt=""></p>
<p><strong>索引</strong></p>
<p>通过索引快速定位日志.</p>
<p><img src="/images/kafka8.jpg" alt=""></p>
<p><strong>一致性</strong></p>
<p>通过ISR在安全和性能之间达到平衡。</p>
<p>AR= ISR+OSR</p>
<p>AR：所有副本(Assigned Repllicas)</p>
<p>ISR：同步副本(In-Sync Replicas)</p>
<p>OSR：滞后副本(Out-Sync Relipcas)</p>
<p>简言之，Kakfa通过动态调整ISR集合的副本来实现性能与数据安全之间的平衡，在网络拥塞和部分副本失效时避免对写入性能产生影响。</p>
<p><strong>分区</strong></p>
<p>通过分区扩展Topic的生产和消费的吞吐量。</p>
<p>思考：分区数量可以无限制增加吗？如何选择合适的分区数量？</p>
<p><img src="/images/kafka9.jpg" alt=""></p>
<p><img src="/images/kafka10.jpg" alt=""></p>
<p><strong>日志格式编码与压缩</strong></p>
<p>节约存储和网络带宽。支持多种消息压缩方式（gzip、snappy、lz4）。可有效减少网络传输量、降低网络 I/O，从而提高整体的性能。</p>
<p>如果对时延有一定的要求，则不推荐对消息进行压缩。</p>
<p><strong>批处理</strong></p>
<p>批量发送消息，可减少通信次数提高网络通信效率。</p>
<p>思考：如何平衡网络利用率和时延？(batch.size、linger.ms、fetch.wait.max.ms)</p>
<p><strong>客户端</strong></p>
<p>双线程处理</p>
<p><img src="/images/kafka11.jpg" alt=""></p>
<center><font color = "#36648B">✎</font><br/><font color = "#36648B">配置参数调优</font></center>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">acks：数据安全，<span class="number">0</span>/<span class="number">1</span>/all</span><br><span class="line">max.request.size：生产者一次发送的数据量最大大小,过大的消息服务端可能拒收。</span><br><span class="line">retries和retries.backoff.ms：重试次数和重试间隔</span><br><span class="line">linger.ms：批量发送时，最大的等待时间</span><br><span class="line">batch.size：批量发送消息的的等待大小,默认<span class="number">16384</span>为<span class="number">16</span>k，配置<span class="number">0</span>则禁止批量发送</span><br><span class="line">buffer.memory：发送线程缓存消息的内存大小，如果满了，发送线程会阻塞</span><br><span class="line">max.block.ms：生产者客户端发送阻塞时长，当buffer.memory满了，发送线程会阻塞，这是最大的阻塞时长，默认<span class="number">60</span>S</span><br><span class="line">compression.type：压缩类型，none(默认)/snappy/gzip/lz4</span><br><span class="line">max.poll.interval.ms：默认<span class="number">30000</span>ms，超过该时长没有poll，消费者组认为该消费者异常auto.offset.reset：默认latest(earliest)</span><br><span class="line">enable.auto.commit和auto.commit.interval.ms：默认<span class="keyword">true</span>，自动提交和提交间隔</span><br><span class="line">max.poll.records：消费者一次拉取最大消息条数</span><br><span class="line">fetch.wait.max.ms：如果没有足够的数据server阻塞等待足够的数据的最大阻塞时间，默认<span class="number">100</span>ms</span><br><span class="line">fetch.max.bytes：消费者一次请求时最大的消息字节数，默认<span class="number">50</span>MB</span><br><span class="line">max.partition.fetch.bytes：消费者一次请求时，每个分区返回的最大消息字节数</span><br><span class="line">log.dirs：日志保存目录，配置多个时kafka会均匀存储有助于提高写入性能，尤其是多个存储盘时</span><br><span class="line">log.retention.&#123;hours|minutes|ms&#125;：时间维度，保存一定的时间</span><br><span class="line">log.retention.bytes：空间维度，到达阈值时删除日志</span><br><span class="line">message.max.bytes：服务端能接收的最大消息大小，默认是<span class="number">977</span>KB，视情况调整。</span><br><span class="line">offsets.retention.minutes：服务端偏移量保存时间，默认<span class="number">24</span>小时，建议调整为和日志保存时间一致</span><br><span class="line"></span><br><span class="line">num.network.threads：broker处理消息的最大线程数（默认为<span class="number">3</span>），建议cpu核数+<span class="number">1</span>  </span><br><span class="line">num.io.threads： broker处理磁盘IO的线程数 （默认为<span class="number">8</span>），建议cpu核数*<span class="number">2</span></span><br></pre></td></tr></table></figure>

<center><font color = "#36648B">✎</font><br/><font color = "#36648B">其他消息系统</font></center>

<p><strong>RabbitMQ:</strong><br>RabbitMQ是基于AMQP协议和Erlang语言开发的开源消息队列。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全，主要应用于对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。</p>
<p><strong>RocketMQ:</strong><br>阿里开源的纯Java开发消息中间件，吞吐量高、高可用性、适合大规模分布式系统应用。其思路起源于Kafka，但并不是Kafka的一个Copy，它对消息的可靠传输及事务性做了优化，在阿里集团被广泛应用于交易、充值、流计算、消息推送、日志流式处理、binglog分发等场景。</p>
<p><strong>ActiveMQ:</strong><br>Apache提供的基于Java实现的开源消息系统，能很好地支持J2EE提出的JMS（Java<br>Message Service,即Java消息服务）规范。JMS是一组Java应用程序接口，类似于JDBC(Java数据库的统一访问接口),<br>是一种与厂商无关的API，使得Java程序能够与不同厂商的消息组件很好地进行通信，目前使用以及市场份额逐渐减少。</p>
<table>
<thead>
<tr>
<th><strong>对比维度</strong></th>
<th><strong>细分维度</strong></th>
<th><strong>ActiveMQ</strong></th>
<th><strong>RocketMQ</strong></th>
<th><strong>RabbitMQ</strong></th>
<th><strong>Kafka</strong></th>
</tr>
</thead>
<tbody><tr>
<td>定位</td>
<td>设计定位</td>
<td>可靠消息传输</td>
<td>可靠消息传输</td>
<td>可靠消息传输</td>
<td>可靠消息传输</td>
</tr>
<tr>
<td>基础对比</td>
<td>成熟度/社区</td>
<td>成熟/高</td>
<td>成熟/中</td>
<td>成熟/高</td>
<td>成熟/高</td>
</tr>
<tr>
<td>开发语言</td>
<td>Java</td>
<td>Java</td>
<td>ErLang</td>
<td>Scala</td>
<td></td>
</tr>
<tr>
<td>持久化</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>客户端</td>
<td>丰富</td>
<td>Java</td>
<td>丰富</td>
<td>丰富</td>
<td></td>
</tr>
<tr>
<td>性能可靠性</td>
<td>可用性</td>
<td>高</td>
<td>非常高</td>
<td>高</td>
<td>非常高</td>
</tr>
<tr>
<td>写入性能</td>
<td>好</td>
<td>很好</td>
<td>好</td>
<td>非常好</td>
<td></td>
</tr>
<tr>
<td>集群管理</td>
<td>独立</td>
<td>nameserver</td>
<td>独立</td>
<td>zookeeper</td>
<td></td>
</tr>
<tr>
<td>功能对比</td>
<td>批量发送</td>
<td>支持</td>
<td>支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td></td>
<td>消费方式</td>
<td>pull</td>
<td>pull</td>
<td>push</td>
<td>pull</td>
</tr>
<tr>
<td></td>
<td>消息清理</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td></td>
<td>重新消费</td>
<td>支持</td>
<td>支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>三种代理方式</title>
    <url>/2020/03/17/%E4%B8%89%E7%A7%8D%E4%BB%A3%E7%90%86%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<center><font color = "#36648B">✎</font><br/><font color = "#36648B">什么是代理？</font></center>



<blockquote>
<p>代理是一种设计模式，提供了另外一种模式对目标对象的访问。可以在不改变目标对象状态的情况下对目标对象的功能进行增强。</p>
<p>核心组成要素：代理对象和目标对象。代理对象对目标对象扩展，并且会调用目标对象。</p>
</blockquote>
<center><font color = "#36648B">✎</font><br/><font color = "#36648B">背景</font></center>

<blockquote>
<p>为某个对象提供一个代理，以控制对这个对象的访问。<strong><em>代理类负责请求的预处理、过滤、将请求分派给委托类处理、以及委托类执行完请求后的后续处理。</em></strong></p>
</blockquote>
<center><font color = "#36648B">✎</font><br/><font color = "#36648B">分类</font></center>

<blockquote>
<p>按生成的时间：</p>
<ol>
<li>静态代理：由程序手动编写，在运行之前就已经生成</li>
<li>动态代理：在程序动态运行时利用反射生成。</li>
</ol>
</blockquote>
<center><font color = "#36648B">✎</font><br/><font color = "#36648B">静态代理使用</font></center>



<blockquote>
<p>组成：目标对象、代理对象、接口。</p>
<p>使用步骤：</p>
<ol>
<li>定义一个接口</li>
<li>编写目标对象实现接口</li>
<li>编写代理对象实现接口。定义一个目标对象的成员变量通过构造传入目标对象</li>
<li>在代理实现的方法中调用目标对象的方法</li>
</ol>
</blockquote>
<center><font color = "#36648B">✎✎</font><br/><font color = "#36648B">代码</font></center>

<p><strong>接口类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICar</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>目标类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmallCar</span> <span class="keyword">implements</span> <span class="title">ICar</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"small call drive ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代理类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyCar</span> <span class="keyword">implements</span> <span class="title">ICar</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ICar iCar;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyCar</span><span class="params">(ICar iCar)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.iCar = iCar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"proxy start ready,execute target object method"</span>);</span><br><span class="line">        iCar.drive();</span><br><span class="line">        System.out.println(<span class="string">"proxy execute target object method end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokeClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建目标实现类</span></span><br><span class="line">        ICar smallCar = <span class="keyword">new</span> SmallCar();</span><br><span class="line">        <span class="comment">// 2. 创建代理类，传入目标类</span></span><br><span class="line">        ProxyCar proxyCar = <span class="keyword">new</span> ProxyCar(smallCar);</span><br><span class="line">        <span class="comment">// 3. 执行代理方法</span></span><br><span class="line">        proxyCar.drive();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">proxy start ready,execute target object method</span><br><span class="line">small call drive ...</span><br><span class="line">proxy execute target object method end</span><br></pre></td></tr></table></figure>

<center><font color = "#36648B">✎✎</font><br/><font color = "#36648B">原理</font></center>

<p>​           在代理类中通过构造函数或者是 set 方法传入接口达到解耦的目的，可以代理多个实现目标类。在代理类的实现方法中，调用目标类的方法。可以灵活的控制在执行目标方法之前和之后增加业务逻辑</p>
<center><font color = "#36648B">✎</font><br/><font color = "#36648B">动态代理</font></center>

<blockquote>
<p>共两种： 1. jdk 动态代理    2. cglib动态代理</p>
<blockquote>
<p> jdk 动态代理</p>
</blockquote>
<p>调用 jdk 的自带的动态代理工具类创建代理类。</p>
<p>位于包：java.lang.reflect.Proxy  下的 newProxyInstance方法</p>
<p>static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h )</p>
<p>三个参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ClassLoader loader,:指定当前目标对象使用类加载器,获取加载器的方法是固定的</span><br><span class="line">Class&lt;?&gt;[] interfaces,:目标对象实现的接口的类型,使用泛型方式确认类型</span><br><span class="line">InvocationHandler h:事件处理,执行目标对象的方法时,会触发事件处理器的方法,会把当前执行目标对象的方法作为参数传入</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p> cglib代理（继承的方式实现）</p>
<p>如果想代理没有实现接口的类,就可以使用Cglib实现。在内存中动态构建子类</p>
</blockquote>
<center><font color = "#36648B">✎</font><br/><font color = "#36648B">jdk动态代理代码</font></center>

<blockquote>
<p>目标对象和接口参加上面的 ICar  SmallCar</p>
</blockquote>
<p><strong>代理工厂类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyFactory</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"开启事务"</span>);</span><br><span class="line">                method.invoke(proxy, args);</span><br><span class="line">                System.out.println(<span class="string">"结束事务"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>调用客户端类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokeClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建目标实现类</span></span><br><span class="line">        ICar smallCar = <span class="keyword">new</span> SmallCar();</span><br><span class="line">        <span class="comment">// 2. 创建代理类，传入目标类</span></span><br><span class="line">        ICar proxy = (ICar)<span class="keyword">new</span> ProxyFactory(smallCar).getProxy();</span><br><span class="line">        <span class="comment">// 3. 执行代理方法</span></span><br><span class="line">        proxy.drive();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<center><font color = "#36648B">✎</font><br/><font color = "#36648B">cglib动态代理代码</font></center>

<p><strong>代理工厂类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxyFactory</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CglibProxyFactory</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CglibProxyFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.工具类</span></span><br><span class="line">        Enhancer en = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">//2.设置父类</span></span><br><span class="line">        en.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">//3.设置回调函数</span></span><br><span class="line">        en.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"开启事务"</span>);</span><br><span class="line">                <span class="comment">//执行目标对象的方法</span></span><br><span class="line">            Object returnValuemethod=method.invoke(target, objects);</span><br><span class="line">                System.out.println(<span class="string">"结束事务"</span>);</span><br><span class="line">                <span class="keyword">return</span> returnValuemethod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//4.创建子类(代理对象)</span></span><br><span class="line">        <span class="keyword">return</span> en.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>调用客户端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokeClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建目标实现类</span></span><br><span class="line">        ICar smallCar = <span class="keyword">new</span> SmallCar();</span><br><span class="line">        <span class="comment">// 2. 创建代理类，传入目标类</span></span><br><span class="line">        ICar proxy = (ICar)<span class="keyword">new</span> CglibProxyFactory(smallCar).getProxy();</span><br><span class="line">        <span class="comment">// 3. 执行代理方法</span></span><br><span class="line">        proxy.drive();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<center><font color = "#36648B">✎</font><br/><font color = "#36648B">spring动态代理代码</font></center>

<p> spring中的核心 aop 思想就用到了动态代理，它的使用思想是：</p>
<blockquote>
<p>如果加入容器的目标对象有实现接口,用JDK代理</p>
<p>如果目标对象没有实现接口,用Cglib代理 </p>
<p>如果目标对象实现了接口，且强制使用cglib代理，则会使用cglib代理。</p>
</blockquote>
<center><font color = "#36648B">✎</font><br/><font color = "#36648B">三种总结</font></center>

<p>对于静态代理的使用场景选择，动态代理用的比较多，灵活性比较高，可以在程序运行的时候生成。并且动态代理可以支持不用必须实现接口的方式提供了两种支持。jdk动态代理的目标对象必须实现接口。但是cglib则并没有要求目标对象必须实现某一个接口。我们可以根据实际情况选择 cglib和jdk 自带的两种代理方式。</p>
]]></content>
      <tags>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title>Thread</title>
    <url>/2020/03/14/Thread/</url>
    <content><![CDATA[<h3 id="1-线程状态转换图"><a href="#1-线程状态转换图" class="headerlink" title="1. 线程状态转换图"></a>1. 线程状态转换图</h3><p><img src="..%5Cimages%5Cthread.png" alt=""></p>
]]></content>
  </entry>
  <entry>
    <title>apache camel</title>
    <url>/2020/01/06/apache-camel/</url>
    <content><![CDATA[<h4 id="开始apache-camel"><a href="#开始apache-camel" class="headerlink" title="开始apache camel"></a>开始apache camel</h4><ol>
<li><p>企业整合模式（EIP）书籍推荐</p>
<blockquote>
<p>&lt; <a href="http://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612" target="_blank" rel="noopener"><em>Design Patterns: Elements of Reusable Object-oriented Softwar</em></a>&gt;</p>
<p>&lt; <a href="http://www.amazon.com/Enterprise-Integration-Patterns-Designing-Deploying/dp/0321200683" target="_blank" rel="noopener"><em>Enterprise Integration Patterns: Designing, Building, and Deploying Messaging Solutions</em></a>&gt;</p>
</blockquote>
</li>
<li><p>apache其它学习方式</p>
<blockquote>
<p>Camel (<a href="http://camel.apache.org/" target="_blank" rel="noopener">http://camel.apache.org</a>) 是一个开源的、基于java的项目，帮助用户实现了多种方式的企业应用的集成。Camel很好了的实现了许多EIP书籍提到的一些设计模式，它是一种不错的方式，让用户能更好的将Camel作为EIP的参考。</p>
</blockquote>
<blockquote>
<p>在线参考文档：<a href="https://camel.apache.org/manual/latest/book-getting-started.html" target="_blank" rel="noopener">https://camel.apache.org/manual/latest/book-getting-started.html</a></p>
<p>组件集成：<a href="https://camel.apache.org/components/3.0.x/index.html" target="_blank" rel="noopener">https://camel.apache.org/components/3.0.x/index.html</a></p>
</blockquote>
<h4 id="camel一些概念和术语"><a href="#camel一些概念和术语" class="headerlink" title="camel一些概念和术语"></a>camel一些概念和术语</h4><p>下面主要介绍和 camel 相关的一些概念和术语，是学习 camel最基本的一步。</p>
<h5 id="ENDPOINT"><a href="#ENDPOINT" class="headerlink" title="ENDPOINT"></a>ENDPOINT</h5><blockquote>
<p>常常被作为</p>
</blockquote>
</li>
</ol>
]]></content>
      <tags>
        <tag>camel</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象与面向过程</title>
    <url>/2020/01/03/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ol>
<li>什么是面向对象</li>
<li>什么是面向过程</li>
<li>面向对象与面向过程区别</li>
<li>面向对象的三大基本特征</li>
<li>面向对象的五大基本原则</li>
</ol>
<h4 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h4><blockquote>
<p>把相关的数据和方法组织为一个整体来看待，从更高的层次来进行系统建模，更贴近事物的自然运行模式</p>
<p>将问题分解为一个一个的步骤，对每个步骤进行相应的抽象，通过不同对象之间的调用，组合解决问题。</p>
<p>就是说，在进行面向对象进行编程的时候，要把属性、行为等封装成对象，然后基于这些对象及对象的能力进行业务逻辑的实现。</p>
<p>例如：要生产一个苹果，就需要对苹果建模，定义一系列属性，定义一系列的行为。抽象成一个Apple类。</p>
</blockquote>
<h4 id="什么是面向过程"><a href="#什么是面向过程" class="headerlink" title="什么是面向过程"></a>什么是面向过程</h4><blockquote>
<p>自顶而下的编程模式。把问题分解成一个一个的步骤，将每个步骤封装为一个个函数，然后依次调用每个函数。上来先定义一个函数，然后使用各种诸如if-else、for-each等方式进行代码执行。</p>
<p>比如实现冒泡排序</p>
</blockquote>
<h4 id="面向对象与面向过程区别"><a href="#面向对象与面向过程区别" class="headerlink" title="面向对象与面向过程区别"></a>面向对象与面向过程区别</h4><blockquote>
<p>设计象棋</p>
<p>面向对象： 构造白棋对象、黑棋对象、棋盘对象、规则对象。面向对象可以复用，不需要重复造轮子。创建一次，重复使用。</p>
<p>面向过程：面向过程:开始—黑走—棋盘—判断—白走—棋盘—判断—循环。只需要关注每一步怎么实现即可.</p>
</blockquote>
<p>优缺点：</p>
<blockquote>
<p>面向对象:占用资源相对高,速度相对慢</p>
<p>面向过程:占用资源相对低,速度相对快</p>
</blockquote>
<p>参考：<a href="https://github.com/hollischuang/toBeTopJavaer/blob/master/basics/java-basic/object-oriented-vs-procedure-oriented.md" target="_blank" rel="noopener">https://github.com/hollischuang/toBeTopJavaer/blob/master/basics/java-basic/object-oriented-vs-procedure-oriented.md</a></p>
<h4 id="面向对象的三大基本特征"><a href="#面向对象的三大基本特征" class="headerlink" title="面向对象的三大基本特征"></a>面向对象的三大基本特征</h4><blockquote>
<p>封装：将属性和行为设计到一个对象中，有些行为和属性暴露，有些私有不暴露</p>
<p>继承：使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。实现继承是指直接使用基类的属性和方法而无需额外编码的能力，接口继承，指的是使用方面的名称，子类必须实现。</p>
<p>实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现</p>
<p>多态：最常见的多态就是将子类传入父类参数中，运行时调用父类方法时通过传入的子类决定具体的内部结构或行为</p>
</blockquote>
<h4 id="五大基本原则"><a href="#五大基本原则" class="headerlink" title="五大基本原则"></a>五大基本原则</h4><blockquote>
<p>单一职责原则：一个类只干一件事</p>
<p>开放封闭原则：抽象类对扩展开放，对修改封闭</p>
<p>李氏替换原则：子类必须能够替换其基类</p>
</blockquote>
]]></content>
      <tags>
        <tag>面向对象，java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>zookeeper-命令行工具zkCli使用</title>
    <url>/2019/12/30/zookeeper-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7zkCli%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h4 id="zkCli使用"><a href="#zkCli使用" class="headerlink" title="zkCli使用"></a>zkCli使用</h4><h5 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h5><blockquote>
<p>必须确保服务器已安装zookeeper</p>
<p>echo ruok|nc 127.0.0.1 2181     使用四字命令检测zookeeper是否运行</p>
</blockquote>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>ZooKeeper客户端有C语言和Java两个版本。</p>
<p>在zookeeper安装目录的/bin文件夹下。</p>
<p>使用如图所示命令表示，使用zkCli.sh连接到zookeeper服务端成功。</p>
<p><img src="/images/zkcli.jpg" alt=""></p>
<h5 id="四字命令"><a href="#四字命令" class="headerlink" title="四字命令"></a>四字命令</h5><table>
<thead>
<tr>
<th><strong>ZooKeeper 四字命令</strong></th>
<th><strong>功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>conf</td>
<td>输出相关服务配置的详细信息。</td>
</tr>
<tr>
<td>cons</td>
<td>列出所有连接到服务器的客户端的完全的连接 / 会话的详细信息。包括“接受 / 发送”的包数量、会话 id 、操作延迟、最后的操作执行等等信息。</td>
</tr>
<tr>
<td>dump</td>
<td>列出未经处理的会话和临时节点。</td>
</tr>
<tr>
<td>envi</td>
<td>输出关于服务环境的详细信息（区别于 conf 命令）。</td>
</tr>
<tr>
<td>reqs</td>
<td>列出未经处理的请求</td>
</tr>
<tr>
<td>ruok</td>
<td>测试服务是否处于正确状态。如果确实如此，那么服务返回“imok ”，否则不做任何相应。</td>
</tr>
<tr>
<td>stat</td>
<td>输出关于性能和连接的客户端的列表。</td>
</tr>
<tr>
<td>wchs</td>
<td>列出服务器 watch 的详细信息。</td>
</tr>
<tr>
<td>wchc</td>
<td>通过 session 列出服务器 watch 的详细信息，它的输出是一个与watch 相关的会话的列表。</td>
</tr>
<tr>
<td>wchp</td>
<td>通过路径列出服务器 watch 的详细信息。它输出一个与 session相关的路径。</td>
</tr>
</tbody></table>
<p>例如使用案例：</p>
<p><img src="/images/zkcli1.jpg" alt=""></p>
<h5 id="常见使用案例"><a href="#常见使用案例" class="headerlink" title="常见使用案例"></a>常见使用案例</h5><ol>
<li><strong>使用 ls 命令来查看当前 ZooKeeper 中所包含的内容</strong></li>
</ol>
<p><img src="/images/zkcli2.jpg" alt=""></p>
<ol start="2">
<li><p>*<em>创建一个新的 znode ，使用 create /mynode  ‘aaa’ 绑定字符串 aaa *</em></p>
<p><img src="/images/zkcli3.jpg" alt=""></p>
</li>
<li><p>*<em>获取节点下面绑定的信息 get /mynode *</em> </p>
<p><img src="/images/zkcli4.jpg" alt=""></p>
</li>
<li><p><strong>通过 set 命令来对 zk 所关联的字符串进行设置： set /mynode ‘ddd’</strong></p>
</li>
<li><p><strong>创建的 znode 删除: delete /mynode</strong></p>
</li>
</ol>
<h5 id="节点各个参数详解："><a href="#节点各个参数详解：" class="headerlink" title="节点各个参数详解："></a>节点各个参数详解：</h5><p>节点的路径皆为绝对路径</p>
<p><img src="/images/zkcli4.jpg" alt=""></p>
<blockquote>
<p>cZxid节点创建时的zxid</p>
<p>ctime节点创建时间</p>
<p>mZxid节点最近一次更新时的zxid</p>
<p>mtime节点最近一次更新的时间</p>
<p>cversion子节点数据更新次数</p>
<p>dataVersion本节点数据更新次数</p>
<p>aclVersion节点ACL(授权信息)的更新次数</p>
<p>ephemeralOwner如果该节点为临时节点,ephemeralOwner值表示与该节点绑定的session id. 如果该节点不是临时节点,ephemeralOwner值为0</p>
<p>dataLength节点数据长度，本例中为hello world的长度</p>
<p>numChildren子节点个数</p>
</blockquote>
]]></content>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>zookeeper概述</title>
    <url>/2019/12/30/zookeeper%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h4 id="zookeeper概述"><a href="#zookeeper概述" class="headerlink" title="zookeeper概述"></a>zookeeper概述</h4><p>zookeeper是一种分布式协调服务，用于大型主机。在分布式环境中，协调和管理服务是一个复杂的过程，但是zookeeper以其简单的机构和 API 解决了该问题。zookeeper最先开始是在 Yahoo 上使用的，用简单而稳健的访问内部的系统。</p>
<h5 id="分布式应用"><a href="#分布式应用" class="headerlink" title="分布式应用"></a>分布式应用</h5><blockquote>
<p><strong>定义</strong>：分布式应用可以在给定时间同时在网络的多个系统上运行，通过协调他们完成共同的任务。复杂的任务在分布式环境下可以用更少的时间完成，不像传统单体应用耗时过多。</p>
<p><strong>组成</strong>：分布式应用有两部分， <strong>Server（服务器）</strong> 和 <strong>Client（客户端）</strong> 应用程序。服务器应用程序实际上是分布式的，并具有通用接口，以便客户端可以连接到集群中的任何服务器并获得相同的结果。 客户端应用程序是与分布式应用进行交互的工具。</p>
</blockquote>
<p><img src="/images/zookeeper.jpg" alt=""></p>
<blockquote>
<p><strong>优点：</strong></p>
<p>可靠性：单个或几个系统故障不会使整个系统奔溃</p>
<p>可扩展性：可以在需要时增加系统的性能，在应用程序进行微小的配置的更改，而不会有停机时间</p>
<p>透明性：隐藏系统的复杂性。</p>
<p><strong>缺点：</strong></p>
<p>竞争条件：两个或多个机器尝试执行特定任务，实际上只需在任意给定时间由单个机器完成</p>
<p>死锁：两个或多个操作等待彼此无限期完成。</p>
<p>不一致: 数据的部分失败</p>
</blockquote>
<h4 id="什么是-Apache-zookeeper"><a href="#什么是-Apache-zookeeper" class="headerlink" title="什么是 Apache  zookeeper?"></a>什么是 Apache  zookeeper?</h4><p>Apache ZooKeeper是由集群（节点组）使用的一种服务，用于在自身之间协调，并通过稳健的同步技术维护共享数据。ZooKeeper本身是一个分布式应用程序，为写入分布式应用程序提供服务。</p>
<blockquote>
<p>提供的服务：</p>
<p><strong>命名服务</strong>: 按名称标识集群中的节点</p>
<p>配置管理：加入节点的最近和最新的配置信息</p>
<p>集群管理：实时的在集群和节点状态中加入/离开节点</p>
<p>选举算法：选举一个节点作为协调目的的leader</p>
<p><strong>高度可靠的数据注册表</strong>：即使在一个或几个节点关闭时也可以获得数据</p>
<p><strong>锁定和同步服务</strong> - 在修改数据的同时锁定数据。</p>
</blockquote>
<blockquote>
<p>优点：</p>
<ul>
<li><strong>简单的分布式协调过程</strong></li>
<li><strong>同步</strong> - 服务器进程之间的相互排斥和协作。此过程有助于Apache HBase进行配置管理。</li>
<li><strong>有序的消息</strong></li>
<li><strong>序列化</strong> - 根据特定规则对数据进行编码。确保应用程序运行一致。这种方法可以在MapReduce中用来协调队列以执行运行的线程。</li>
<li><strong>可靠性</strong></li>
<li><strong>原子性</strong> - 数据转移完全成功或完全失败，但没有事务是部分的。</li>
</ul>
</blockquote>
]]></content>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>小工具-StopWatch</title>
    <url>/2019/12/27/%E5%B0%8F%E5%B7%A5%E5%85%B7-StopWatch/</url>
    <content><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><blockquote>
<p>平时我们在优化代码时，必不可少的需要知道每一段业务逻辑的耗时情况。之前我习惯了用如下这种方式去打印每一段的耗时情况。一段逻辑复杂时，可能整段代码都是 如下，这种方式打印也不直观，直到发现 spring 本身的 util 包下有个工具StopWatch，才发现是如此的好用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">long start &#x3D; System.currentTimeMillis();</span><br><span class="line">handle();</span><br><span class="line">long end &#x3D; System.currentTimeMillis();</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="StopWatch使用"><a href="#StopWatch使用" class="headerlink" title="StopWatch使用"></a>StopWatch使用</h4><p>类构造方法、普通方法、属性概览：</p>
<p><img src="images/stopwatch.jpg" alt=""></p>
<p>使用步骤：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StopWatch stopWatch = <span class="keyword">new</span> StopWatch(<span class="string">"bussiness Id"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码片段1</span></span><br><span class="line">stopWatch.start(<span class="string">"bussiness1"</span>);</span><br><span class="line">executeBussiness1();</span><br><span class="line">stopWatch.stop();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码片段2</span></span><br><span class="line">stopWatch.start(<span class="string">"bussiness2"</span>);</span><br><span class="line">executeBussiness2();</span><br><span class="line">stopWatch.stop();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印所有片段执行情况</span></span><br><span class="line">String recordInfo = stopWatch.prettyPrint();</span><br><span class="line">System.out.println(recordInfo);</span><br></pre></td></tr></table></figure>



<p>源码学习的点：</p>
<blockquote>
<p>由于底层是用一个linkList来记录每一段代码的执行，所有不要使用在多线程的环境中，是线程不安全的。可以通过 taskList 得到所有片段执行的情况。</p>
</blockquote>
]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>java五种单例模式</title>
    <url>/2019/12/25/java%E4%BA%94%E7%A7%8D%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h4 id="✎简介"><a href="#✎简介" class="headerlink" title="✎简介"></a><center><font color = "#36648B">✎</font><br/><font color = "#36648B">简介</font></center></h4><pre><code>单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。
本篇文章主要来简介下五种常见的单例模式【实现方法】以及【各自的区别】。
五种方式：懒汉式、饿汉式、双校验锁、静态内部类、枚举。</code></pre><hr>
<h4 id="✎-懒汉式"><a href="#✎-懒汉式" class="headerlink" title="✎ 懒汉式"></a><center><font color = "#36648B">✎</font><br/><font color = "#36648B"> 懒汉式</font></center></h4><h5 id="☞代码"><a href="#☞代码" class="headerlink" title="☞代码"></a>☞代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Apple apple = <span class="keyword">new</span> Apple();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FruitFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Apple <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> apple;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="☞总结"><a href="#☞总结" class="headerlink" title="☞总结"></a>☞总结</h5><blockquote>
<ol>
<li>场景：适用于占用内存较小的小对象。懒汉式实例化的时机是在类加载的时候对实例进行创建。</li>
<li>优点：在多线程中不会关心是否加锁同步类的问题。</li>
<li>缺点：不管是否使用该实例，都会被实例化到内存中去。</li>
</ol>
</blockquote>
<hr>
<h4 id="✎饿汉式"><a href="#✎饿汉式" class="headerlink" title="✎饿汉式"></a><center><font color = "#36648B">✎</font><br/><font color = "#36648B">饿汉式</font></center></h4><h5 id="☞代码-1"><a href="#☞代码-1" class="headerlink" title="☞代码"></a>☞代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Apple apple = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FruitFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Apple <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (apple == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Apple();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> apple;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="☞总结-1"><a href="#☞总结-1" class="headerlink" title="☞总结"></a>☞总结</h5><blockquote>
<p>场景： 适用单线程环境并且对象占用内存较大的场景。<br>优点： 只是在调用的时候才会实例化对象，跟懒汉的模式是不一样的。<br>缺点： 不能适用多线程的场景，需要加锁解决线程同步问题。</p>
</blockquote>
<hr>
<h4 id="✎双校验锁"><a href="#✎双校验锁" class="headerlink" title="✎双校验锁 "></a><center><font color = "#36648B">✎</font><br/><font color = "#36648B">双校验锁 </font></center></h4><h5 id="☞-代码"><a href="#☞-代码" class="headerlink" title="☞ 代码"></a>☞ 代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Apple apple = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FruitFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Apple <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(apple == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (FruitFactory<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (apple == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> Apple();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> apple;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="☞总结-2"><a href="#☞总结-2" class="headerlink" title="☞总结"></a>☞总结</h5><blockquote>
<p>场景：适用多线程，延迟加载的场景<br>优点：可以用在多线程下面，在 1.5 之后的版本中用  volatile 解决了校验锁会失效的问题<br>缺点：1.4 之前的版本没有 volatile 关键字，可能会有失败的情形，因为涉及到指令的重排序<br>两次校验原因：<br>a.  第一次判断 singleton 是否为 null: 是为了在第一次创建实例化后，后面获取不用再进入同步代码块中，提高了性能<br>b. 第一次判断 singleton 是否为 null: 假设其中一个线程进行判断准备进入同步代码块，但是另外一个线程获得调度的时间片，这是没有实例化满足为null的情况进入同步快中，实例完后，前面的线程获得锁然后继续执行又创建一个实例。所以里面的判断是必要的。<br>c. 用 volatile原因： volatile 可以保证可见性和原子性，同时保证 JVM 对指令不会进行重排序 new Apple() 是分几步执行的：<br>   指令1：获取apple对象的内存地址<br>  指令2：初始化apple对象<br>  指令3：将这块内存地址，指向引用变量apple。<br>加入重排后的执行指令按 2-1-3 执行，线程 a 执行到指令1时，另外一个线程 b 去调用getInstance 获得对象就不是完整的，就会导致异常的产生。</p>
</blockquote>
<hr>
<h4 id="✎静态内部类"><a href="#✎静态内部类" class="headerlink" title="✎静态内部类 "></a><center><font color = "#36648B">✎</font><br/><font color = "#36648B">静态内部类 </font></center></h4><h5 id="☞代码-2"><a href="#☞代码-2" class="headerlink" title="☞代码"></a>☞代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitInstance</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Apple apple = <span class="keyword">new</span> Apple();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Apple <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> FruitInstance.apple;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="☞总结-3"><a href="#☞总结-3" class="headerlink" title="☞总结"></a>☞总结</h5><blockquote>
<p>场景：适用于多线程，延迟加载的场景<br>优点：只在调用的时候才加载实例化内部类<br>缺点：可以强制利用反射来调用私有构造</p>
</blockquote>
<hr>
<h4 id="✎枚举"><a href="#✎枚举" class="headerlink" title="✎枚举 "></a><center><font color = "#36648B">✎</font><br/><font color = "#36648B">枚举 </font></center></h4><h5 id="☞代码-3"><a href="#☞代码-3" class="headerlink" title="☞代码"></a>☞代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> FruitType &#123;</span><br><span class="line"></span><br><span class="line">    Apple;</span><br><span class="line">    <span class="keyword">private</span> Apple apple;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FruitType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        apple = <span class="keyword">new</span> Apple();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Apple <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Apple.apple;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="☞总结-4"><a href="#☞总结-4" class="headerlink" title="☞总结"></a>☞总结</h5><blockquote>
<p>明确了构造方法限制为私有，在我们访问枚举实例时会执行构造方法<br>枚举实例都是static final类型的,所以只会实例化一次<br>枚举除了线程安全和防止反射调用构造器之外，还提供了自动序列化机制，防止反序列化的时候创建新的对象</p>
</blockquote>
<h4 id="✎对比"><a href="#✎对比" class="headerlink" title="✎对比 "></a><center><font color = "#36648B">✎</font><br/><font color = "#36648B">对比 </font></center></h4><table>
<thead>
<tr>
<th>方式</th>
<th>是否线程安全</th>
</tr>
</thead>
<tbody><tr>
<td>懒汉式</td>
<td>是</td>
</tr>
<tr>
<td>饿汉式</td>
<td>否</td>
</tr>
<tr>
<td>双校验</td>
<td>是</td>
</tr>
<tr>
<td>静态内部类</td>
<td>是</td>
</tr>
<tr>
<td>枚举</td>
<td>是</td>
</tr>
</tbody></table>
<p><strong>参考：</strong> </p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式，单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub+Hexo搭建博客系统</title>
    <url>/2019/12/24/GitHub-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
</search>
